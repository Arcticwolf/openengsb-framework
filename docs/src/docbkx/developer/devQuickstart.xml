<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!--

   Copyright 2010 OpenEngSB Division, Vienna University of Technology

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

-->
<chapter id="devQuickstart" xmlns="http://docbook.org/ns/docbook">
  <title>Getting Started as a Developer</title>
  <para>
    This chapter gives an overview how to quickly start with the OpenEngSB.
  </para>
  <section id="devQickstart.pre">
    <title>Prerequisites</title>
    <para>
      First of all the JDK 6 has to be installed on the system and the <code>JAVA_HOME</code> variable has to be set accordingly.
      All further steps are described in the subsections of this chapter.
    </para>
    <section id="devQickstart.pre.git">
      <title>Installing Git</title>
      <para>
        Further more its assumed that Git had been installed. For Git we recommend the latest Cygwin with the Git
        packages. Please set at least the following variables:
      </para>
      <programlisting>git config --global user.name "Firstname Lastname"
git config --global user.email "myaddress@example.com"
git config --global core.autcrlf input</programlisting>
    </section>
    <section id="devQickstart.pre.maven">
      <title>Installing Maven</title>
      <para>
        Finally download Apache Maven and unpack it. Add the path of the maven binary to your PATH variable. Further more
        you should set the MAVEN_OPTS environment variable to allow Maven to use more RAM. If you don't you'll get
        Out Of Memory errors.
        <programlisting>export PATH=$PATH:/path/to/maven/bin
export MAVEN_OPTS='-Xmx1024M -XX:MaxPermSize=512m'</programlisting>
      Add these commands to <code>~/.bashrc</code> to make the settings permanent.
      </para>
    </section>
    <section id="devQickstart.pre.smx">
      <title>Installing Servicemix</title>
      <para>
        Download the latest version of Apache Servicemix from <ulink url="http://servicemix.apache.org/" />.
        After unpacking it you can start it by executing <code>bin/servicemix</code>.
      </para>
    </section>
  </section>
  <section id="devQickstart.essential">
    <title>Starting OpenEngSB</title>
    <para>
      The next step is to get the OpenEngSB source by checking out the current master using git:
      <programlisting>git clone git://github.com/openengsb/openengsb</programlisting>
      Now start Servicemix with the scripts in <code>servicemix/bin/</code>.
      Finally build and deploy the OpenEngSB to Servicemix:
      <programlisting>scripts/quickrun.sh</programlisting>
    </para>
  </section>
  <section id="devQickstart.eclipse">
    <title>Using Eclipse</title>
    <para>
      Eclipse had been chosen by the OpenEngSB team as the main development environment. After checkout the code the
      following command creates the required Eclipse project files:
    </para>
    <programlisting>mvn eclipse:configure-workspace
mvn eclipse:eclipse</programlisting>
    <para>
      Start Eclipse and select <emphasis>File, Select Workspace, Other...</emphasis> and choose the
      <code>eclipse-workspace</code> directory. This is a subdirectory of the OpenEngSB source.
      After Eclipse restarted you can import the projects:
      <emphasis>File, Import..., Existing Projects into Workspace</emphasis>. As the root directory select
      the root of the OpenEngSB source. Eclipse will list several projects and for now it's best to import
      them all by clicking <emphasis>Finish</emphasis>.
    </para>
  </section>
  <section id="devQickstart.structure">
    <title>Folder Structure</title>
    <para>
      This section describes the directory structure of OpenEngSB. Since this project contains a huge amount of
      projects they are divided into a hierarchy. Namely there are three parts in the directory structure
      which should be explained step by step. The name of the projects is always generated by the directory
      hierarchy. For example a project nested in <code>features/edb/core</code> would 
      be named <code>openengsb-features-edb-core</code>.
    </para>
    <para>
      The following structure shows the core projects for OpenEngSB. If a new project is created which es a part of
      the core of the OpenEngSB and which could not be separated at all it would create a new subdirectory in this tree.
      Because of the JBI project structure it is required that more than one project is nested in each subnode (at least
      service-unit and service-engine).
    </para>
    <programlisting>openengsb
openengsb/ekb
openengsb/config
openengsb/context
openengsb/package
openengsb/core
openengsb/workflow
openengsb/workflow/drools
openengsb/workflow/bpel
openengsb/testing</programlisting>
    <para>
      Beside of the core packages there are additional packages extending the OpenEngSB with additional features and
      therefore stored in a feature subdirectory. These projects could not exist without the OpenEngSB but the OpenEngSB
      could exist withouh them. They are designed to fulfill a specific purpose to extend the functionality of the OpenEngSB,
      but may not be interesting for most users. For this reason the folder is nested in a deeper structure.
      Features as the "edb" or "link" could be found here.
    </para>
    <programlisting>openengsb
openengsb/features
openengsb/features/edb
openengsb/features/link</programlisting>
    <para>
      The last part of the file structure contains the core packages for the OpenEngSB; its domains and connectors. As
      will be explained later in more detail the OpenEngSB integrates tools differently than a "regular" enterprise
      service bus. An enterprise service bus directly integrates tools, where the OpenEngSB adds an additional abstraction
      layer via domains. This structure is also shown in the directory hierarchy. Domains are stored in a separate subdirectory,
      since they are to be separated into subprojects in the future.
    </para>
    <para>
      Each domain could be found in the <code>openengsb/domains</code> directory. Domains cover mostly one huge part in the engineering
      domain as SCM, Notification, Issues and so on. Therefore for each of these parts an additional subfolder had been
      created. The domain itself could be found in the
      <code>openengsb/domains/<emphasis>Domain</emphasis>/implementation</code> subdirectory of a domain. This folder will
      always contain at least a service-engine or a binding-unit and a service-unit. The service-engine or binding-unit
      are required to implement the domain logic at all where the service-unit is required to configure the domain. Domains
      are always configured only once in one OpenEngSB instance which explains why they are defined directly in the project.
    </para>
    <para>
      Beside the domains the real tool implementations could be found. For the notification domain useful implementations
      are, as shown, the Email and Jabber implementations which allows to send notifications via Jabber or Email. Regulary
      the service-engine is implemented, in this case directly in the root folder (.../email or .../jabber) since the service-unit
      is created at runtime for such components.
    </para>
    <para>
      The last interesting part in the domain directory is <code>openengsb/domains/toolAbstraction</code>. This directory contains
      projects which "generally abstract" tools to a higher and better usable level and if its required to use this
      abstraction layer above several domain-tool-connectors. For example the additionally required infrastructure for the
      SVN connector would not make any sense in the additional tool abstraction layer since it is only required once for
      implementing the SVN connector for the SCM domain. But compared to that Maven could be used for more than one
      tool-domain. Maven could be used at least for Build, Test and Deploy. Therefore there would be duplicated code
      to abstract the tool to the needs of the connectors. The toolAbstraction folder is the right place for additional
      abstractions required for use cases as described with the Maven project.
    </para>
    <programlisting>openengsb
openengsb/domains
openengsb/domains/toolAbstraction
openengsb/domains/notification
openengsb/domains/notification/implementation
openengsb/domains/notification/email
openengsb/domains/notification/jabber
openengsb/domains/scm</programlisting>
    <para>
      Since the number of projects increases steadily it is required to fit all projects
      into this structure so it's maintainable.
    </para>
  </section>
  <section id="devQickstart.assembly">
    <title>Assembling OpenEngSB</title>
  <section id="devQickstart.assembly.introduction">
    <title>Introduction</title>
    <para> This section gives a short overview about the assembly procedure of OpenEngSB. Furthermore a short
      description of the structure of the assembled project is given.
  </para>
  </section>
  <section id="devQickstart.assembly.howto">
    <title>How to assemble OpenEngSB</title>
    <para>
      To create a distributable form of OpenEngSB simply run <code>scripts/assemble.sh</code>.
      Two zip files are created in the target folder of the project root. The structure of the zips is explained in the following section.
      The zip files are called <code>openengsb-<emphasis>version</emphasis>-windows.zip</code> and
      <code>openengsb-<emphasis>version</emphasis>-unix.zip.</code> After
      unzipping the assembly Servicemix can be started using the openengsb executable
      in the <code>apache-servicemix-<emphasis>version</emphasis>/bin/</code> directory. The OpenEngSB
      components are already included in the hotdeploy directory of Servicemix and will be started automatically on Servicemix startup.
    </para>
  </section>
  <section id="devQickstart.assembly.structure">
    <title>Structure</title>
    <para>
      <programlisting>        openengsb-{version}
        |
        |- docs
        |    |
        |    |- html
        |    |- pdf
        |
        |- servicemix
        |    |
        |    |
        |    |- deploy (openengsb components)
        |    |- bin (executable to start servicemix - openengsb.bat or openengsb.sh)
        |
        |- README
        |- LICENSE
        |- NOTICE</programlisting>
    </para>
  </section>
  </section>
  <section id="git">
    <title>Git Documentation</title>
    <section>
        <title>Usage</title>
        <para>
        First of all this chapter explains only the <emphasis>very</emphasis> basics of Git and only that parts directly relevant for the
        development of the OpenEngSB project, but not the entire idea and possibilities of Git.
        <emphasis>Please</emphasis> read some
        tutorials first to get how to work with Git and see this chapter more as an summary! You may also take a look
        at the <ulink url="http://git-scm.com/documentation/">Git Documentation Page</ulink> and the
        <ulink url="http://progit.org/book/">Pro Git Book</ulink>.
        </para>
    </section>
    <section>
      <title>Remarks</title>
      <para>
        If you are using Windows then the best way to work with Git is using
        <ulink url="http://www.cygwin.com/">Cygwin</ulink>. The packages openssh, git and gitk are required.
      </para>
    </section>
    <section>
      <title>Github</title>
      <para>OpenEngSB is developed at
        <ulink url="http://github.com/">github.com</ulink>. Please create an account there and explore its features.
        Specify your real name in the admin tab and add a picture. This makes it easier to associate your commits to you.
      </para>
    </section>
    <section>
      <title>Starting up and configure</title>
      <para>
      Before starting to work with Git some settings should be applied to Git. Therefore simply execute the following
 commands.

  <programlisting>git config --global user.name "FirstName LastName"
git config --global user.email "user@example.com"
git config --global color.ui "auto"
git config --global pack.threads "0"
git config --global diff.renamelimit "0"
git config --global core.autocrlf "input"</programlisting>

  Additionally execute the special settings for github as could be found on github in the "Account Settings"
 tab is a point "Global git config information". Please use the two git commands described there

  <programlisting>git config --global github.user <emphasis>username</emphasis>
git config --global github.token <emphasis>token</emphasis></programlisting>

 If you don't already have an SSH key you can create one by executing

<programlisting>ssh-keygen</programlisting>

  Simply answer all questions from the application with "enter" without enter any values. Afterwards the content of the id_rsa.pub
 file from your ~/.ssh/ folder should be submitted to github ("Account Settings"/"SSH public keys").
    </para>
    </section>
    
    
    <section>
        <title>Contributor Workflow</title>
        <para>
        Contributor are all developer who like to contribute to the OpenEngSB project, but not have commit rights to the
 master. Nevertheless the same workflow is also valid for commiter with the difference that they have additional
 responsibilities.
        </para>
        <section>
            <title>Initial Setup</title>
            <para>
              Create a fork from <ulink url="http://github.com/openengsb/openengsb/">the OpenEngSB repository at github</ulink>.
              Click on the button <emphasis>Fork</emphasis> and follow the instructions there.
              
              Now clone the original repo:
              <programlisting>git clone git://github.com/openengsb/openengsb</programlisting>
              If you are a committer with write access this would be:
              <programlisting>git clone git@github.com:openengsb/openengsb</programlisting>
              
              Add your fork as remote branch:
              <programlisting>git remote add <emphasis>username</emphasis> git@github.com/<emphasis>username</emphasis>/openengsb</programlisting>
              Example: <programlisting>git remote add ChristophGr git@github.com/ChristophGr/openengsb</programlisting>
            </para>
        </section>
        <section>
            <title>Creating a new Branch for a feature</title>
            <para>
              It's always a good idea to synchronize your local Git repository with all the external repositories.
              This is done by executing:
              <programlisting>git remote update -p</programlisting>
              
              Now create your branch:
              <programlisting>git checkout -b <emphasis>branchname</emphasis> origin/master</programlisting>
              
              Push the new branch to your fork:

              <programlisting>git push <emphasis>username</emphasis> <emphasis>branchname</emphasis></programlisting>

              Go to the admin page of your fork and set the default branch to <emphasis>branchname</emphasis>

              Create a new development branch:

              <programlisting>git checkout -b devbranch <emphasis>branchname</emphasis></programlisting>
            </para>
        </section>
        <section>
            <title>Working With Your Branch</title>
            <para>
              Start coding and commit your changes to the devbranch. Please make small commits and write meaningful
              commit messages.
            </para>
        </section>
        <section>
            <title>Publishing Your Work</title>
            <para>
              Update your local feature branch by changing from devbranch to MYFEATURE:
              <programlisting>git checkout MYFEATURE</programlisting>

              Synchronize your feature with your remote repository:
              <programlisting>git pull <emphasis>username</emphasis> <emphasis>branchname</emphasis></programlisting>

              Rebase your devbranch with your feature branch:
              <programlisting>git rebase <emphasis>branchname</emphasis> devbranch</programlisting>

              Go back to the feature branch:
              <programlisting>git checkout <emphasis>branchname</emphasis></programlisting>

              Merge your devbranch into the feature branch
              <programlisting>git merge devbranch</programlisting>

              Push the changes:
              <programlisting>git push <emphasis>username</emphasis> <emphasis>branchname</emphasis></programlisting>

              If you want to continue working on this branch then check it out:
              <programlisting>git checkout devbranch</programlisting>
            </para>
        </section>
        <section>
            <title>Long-Time Development Features</title>
            <para>
            If the development in the branch takes some time, it may happen, that the master-branch changes in a way that
            affects your featurebranch. To check how your branch behaves on the current master you can merge the changes into your devbranch.

            <programlisting>git checkout <emphasis>branchname</emphasis>
git merge --no-commit --no-ff origin/master</programlisting>
  
            If it does not affect your development in any way, do not commit the merge, but rather undo it.

            <programlisting>git reset --hard</programlisting>

            If it does affect your development, you need to commit the merge. If the merge breaks something in your devbranch, fix all
            issues before commiting the merge.  When done fixing potential issues do

            <programlisting>git commit</programlisting>
            </para>
        </section>
        <section>
            <title>Finish Feature</title>
            <para>
              If you think you are finished with your feature please post to the OpenEngSB developer list.
              A committer will decide if he will merge your branch or give you feedback.
            </para>
        </section>
    </section>
    <section>
        <title>Commiter Workflow</title>
        <para>
          The only difference between a committer and a contributor is that he has to watch and merge branches of
          contributors. If a commiter is happy with the work of a contributor. Comments and other discussions should be
          done on the mailing list and/or via the github review system. Committers should always watch the branches
          and forks of contributors to review, comment and give feedback as soon as possible.
        </para>

        <para>
          To merge a branch of a contributor the following steps has to be done. The following preconditions are relevant:
          <orderedlist>
            <listitem>You want to merge a feature MYFEATURE</listitem>
            <listitem>from a user USERNAME</listitem>
            <listitem>and openengsb/openengsb repository is your origin repository.</listitem>
          </orderedlist>


          First of all you have to add the user's fork as a remote repository
          <programlisting>git remote add USERNAME git://github.com/USERNAME/openengsb</programlisting>

          Now update the remote repository
          <programlisting>git remote update -p</programlisting>

          Checkout the origin master
          <programlisting>git checkout -b master origin/master</programlisting>

          Merge the feature branch
          <programlisting>git merge USERNAME/MYFEATURE --no-ff</programlisting>

          Push the changes to the master
          <programlisting>git push origin master</programlisting>
        </para>
    </section>
    <section>
        <title>Additional Rules</title>
        <para>
          <orderedlist>
            <listitem>
              (Contributor/Committer)
              All development is done in forks (also of the core developers)
              One exception to this rule exists: Small fixes and maintenance work which is NOT related to a new feature and does not exceed 2 commits should be rebased and merged (or cherry-picked) into the master directly.         
            </listitem>
            
            <listitem>
              (Contributor/Committer)
              Rebase is NOT dead (although we use merges). NEVER EVER commit local
              merges. You still have to develop in local dev branches and rebasing them
              with the upstream branches. Only if nobody else has access to your fork you
              can be sure that nobody changed it!
            </listitem>
            
            <listitem>
              (Committer)
              Merges to the master have to be done from the upstream branches not the
              local ones! This means if you want to merge the branch test from the fork
              eyeball into the master do NOT use
            
              <programlisting>git checkout test eyeball/test
git checkout master
git merge test</programlisting>

              but rather
              <programlisting>git checkout master
git merge eyeball/test
</programlisting>

              This will create much better readable merge nodes.
            </listitem>

            <listitem>
              (Committer)
              If merging branches from forked repositories ALWAYS use the --no-ff option
              for merges; this will always create a merge node (even if a fast-forward
              merge is possible). This is required to create a clear and consistent
              history!
            </listitem>
            
            <listitem>
              Avoid backward merges from the master and keep feature branches small!
              This does not mean that backward merges from master are forbidden. But they should
              not be done too often, since they create a history not easy to read. Please use
              the method described on this page (with --no-ff --no-commit) to reduce the number
              of merge nodes.
            </listitem>

            <listitem>
              Use <emphasis>meaningful</emphasis> feature branch names. Using the merge history in the master
              you can easily follow the development of features. But this requires (maybe
              long) good names!
            </listitem>
            
            <listitem>
              Keep your forks clean. Although git can handle thousands of branches in
              thousands of forks we (as committers) can't. Having all the forks as remote
              repositories makes it really hard for us to handle all the branches in all
              the forks. Therefore please remove ALL branches already merged or not
              required. Also remove your forked master and the already existing branches.
              You can remove your local master by changing in the admin page of your fork
              the default branch to your current branch; if master is no longer the
              default branch you can kick it. Additionally it's nevertheless better to use
              the remote master instead of your forked to kick off your dev branches.
            </listitem>
          </orderedlist>
        </para>
    </section>
    </section>
    <section>
        <title>Java Coding Style</title>
        <section>
            <title>Sun Coding Guidelines</title>
            <para>
              The OpenEngSB Coding Guidelines are based upon the
              <ulink url="http://java.sun.com/docs/codeconv/html/CodeConvTOC.doc.html">Code
              Conventions for the Java Programming Language</ulink>.  There are some additions and
              deviations for this project.
            </para>
            <section>
                <title>Line lenght</title>
                <para>
                  A line length of 80 was standard 10 years ago, but with increasing screen
                  size and resolution a length of 120 is more reasonable.
                </para>
            </section>
            <section>
                <title>Wrapping</title>
                <para>
                Use the auto-formatter of your IDE. Import the
                <ulink url="http://dev.openengsb.org/resources/eclipse/formatter.xml">Eclipse Formatter file</ulink>.
                </para>
            </section>
            <section>
                <title>Nubmer of declarations per line</title>
                <para>
                  Only one declaration per line is allowed.
                </para>
            </section>
            <section>
                <title>Declaration placement</title>
                <para>
                  Declare variables where they are needed. It's easier to read and restricts the
                  scope of variables.  Don't overshadow variables.
                </para>
            </section>
            <section>
                <title>Blank lines</title>
                <para>
                  The body of a method should not start with a blank line.
                </para>
            </section>
        </section>
        <section>
            <title>General</title>
            <section>
                <title>File format</title>
                <para>
                  Every Java file has to be UTF-8 encoded and has to use UNIX line endings.
                  Indentations consist of four spaces, tab-stops are not allowed.
                </para>
            </section>
            <section>
                <title>Header</title>
                <para>
                  Every source file has to start with this header:
<programlisting>/**

   Copyright 2010 OpenEngSB Division, Vienna University of Technology

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE\-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

*/
</programlisting>
                </para>
            </section>
            <section>
                <title>Duplication</title>
                <para>
                  Code duplication has to be avoided at all costs.
                </para>
            </section>
            <section>
            <title>Use guards</title>
            <para>
              Guards are a possibility to reduce the amount of nesting.  Heavily nested
 code is much harder to read.
 
Bad:
<programlisting>  public void foo() {
      if (conditionA) {
          if (conditionB) {
              if (conditionC) {
                  // do some work
              }
          } else {
              throw new MyException();
          }
      }
  }</programlisting>

 Good:
<programlisting>  public void foo() {
    if (!conditionA) {
        return;
    }

    if (!conditionB) {
        throw new MyException();
    }

    if (!conditionC) {
        return;
    }

    // do some work
  }</programlisting>

            </para>
            </section>
            <section>
                <title>Keep methods short</title>
                <para>
                  Methods longer than 40 lines are candidates for refactoring. A method should only
                  do one thing and has to be easily understandable. The number of arguments should be
                  minimized.  A method should only be at a single level of abstraction.
                </para>
            </section>
            <section>
                <title>Use enums</title>
                <para>
                  Prefer typesafe enumerations over integer constants.
                </para>
            </section>
            <section>
                <title>Avoid use of static members</title>
                <para>  Static members are a sign of a design error because they are like global variables.
                It's fine if you declare a constant as final abstract of course.
                </para>
            </section>
            <section>
                <title>Use fully qualified imports</title>
                <para>
                  Don't import org.example.package.*, instead import the needed classes.
                </para>
            </section>
            <section>
                <title>Never declare implementation types</title>
                <para>
                  Use interfaces or the abstract base class instead of concrete implementation
                  classes where possible.
 
                  Don't write:
                  <programlisting><![CDATA[ArrayList<String> names = new ArrayList<String>();]]></programlisting>

                  Instead use the interface name:
                  <programlisting><![CDATA[List<String> names = new ArrayList<String>();]]></programlisting>

                  This is especially important in method signatures.
                </para>
            </section>
            <section>
                <title>SerialVersionUID</title>
                <para>
                  Don't declare serialVersionUID just because your IDE tells you. Have a good reason
                  why you need it.  This can cause bugs that are hard to detect.
                </para>
            </section>
            <section>
                <title>Restrict scope of suppressed warnings</title>
                <para>
                 If you have to suppress a warning make sure you give it the smallest possible scope.
                 This means you should never annotate a whole class with @SuppressWarnings. A method may
                 be acceptable but you should try to annotate the problematic statements instead.
                </para>
            </section>
            <section>
                <title>Use String.format()</title>
                <para>
                  Use String.format() instead of long concatenation chains which are hard to read.
                </para>
            </section>
            <section>
                <title>Array declaration style</title>
                <para>
                  Always use
                  <programlisting> Type[] arrayName;</programlisting>

                  instead of the C-like
                  <programlisting>Type arrayName[];</programlisting>
                </para>
            </section>
            <section>
                <title>Comments</title>
                <para>
                  Don't make funny comments, be professional. All comments have to be in English.
                  Comment what methods do, not how they do it. Do not comment what is already stated
                  in code.
                </para>
            </section>
        </section>
        <section>
            <title>Naming</title>
            <section>
                <title>Interfaces</title>
                <para>
                  Interfaces are not marked by starting their names with I.  This exposes
                  more information than necessary and is not Java-like.
                </para>
            </section>
            <section>
                <title>Don't abbreviate</title>
                <para>
                  Do not use abbreviations if it's not a project wide standard. Long method names
                  are preferable to inconsistency.  With automatic code completion this isn't a problem
                  anyway.
                </para>
            </section>
        </section>
        <section>
            <title>No clutter</title>
            <para>
              <itemizedlist>
                <listitem>Exception/Log Messages have to be concise. Don't end messages with "...".</listitem>

                <listitem>Don't overuse FINAL, use it where you have a good reason something has to be
                  final.  Although it doesn't hurt to declare everything as final it clutters the
                  code.
                </listitem>
                
                <listitem>Don't use history tables in source files.  Use the SCM system if you are
                  interested in the changes of a file.
                </listitem>
                
                <listitem>Don't use the JavaDoc author tag.  Also use the SCM system.</listitem>

                <listitem>Don't declare unnecessary constructors, especially the empty default constructor.</listitem>
                
                <listitem>Don't make implicit calls explicitly, i.e. calling super(); in every constructor.</listitem>
                
                <listitem>Don't specify modifiers that are implicit, i.e. don't make methods in interfaces
                  <code>public abstract</code>.</listitem>
                  
                <listitem>Don't initialize fields with null, they are automatically initialized with null.</listitem>
                
                <listitem>Don't use banners in comments.</listitem>
                
                <listitem>Don't use closing brace comments, i.e. } // end if, they are a sign of too long
                  methods.</listitem>
                  
                <listitem>Don't comment out code and commit it. This confuses programmers why it is there.
	               Simply delete it, it's still present in the SCM history.
                </listitem>
              </itemizedlist>
            </para>
        </section>
        <section>
            <title>Exception Handling</title>
            <para>
              <itemizedlist>
                <listitem>Don't log and throw. Either a exception should be logged or thrown to be processed
                  at a more appropriate place.
                </listitem>
                  
                <listitem>Don't swallow exceptions silently. If you have to do it, you have to make a comment
                  stating the reason.
                </listitem>
                
                <listitem>Use runtime exceptions where possible.</listitem>

                <listitem>Wrap exceptions in a RuntimeException if you don't want to specify the Exception in
	               your method signature and you can't handle it.
                </listitem>
                
                <listitem>
                  Write meaningful exception message.
                </listitem>
              </itemizedlist>
            </para>
        </section>
        <section>
            <title>Tests</title>
            <section>
                <title>General</title>
                <para>
                  <itemizedlist>
                    <listitem>Make use of JUnit 4 features, e.g. @Test(expected = SomeException.class)</listitem>
                    
                    <listitem>Tests should not output anything. They have to be automatically verified.</listitem>
                    
                    <listitem>Don't catch exceptions just to fail manually. Declare the method to throw the exception.</listitem>
                    
                    <listitem>Install a shutdown hook for test data files. This assures that they will be deleted and the
	                  project remains in a clean state.
                    </listitem>
                   
                   <listitem>Use <ulink url="http://code.google.com/p/mockito/">Mockito</ulink> for mocking.</listitem>
                   
                   <listitem>
                    Tests should have descriptive method names. It should be deducible what will be tested.
                    Bad: <code>testError()</code>. 
                    Good: <code>invalidInMessageShouldReturnErrorResponse()</code>.
                   </listitem>
                 </itemizedlist>
                </para>
            </section>
            <section>
                <title>Naming Scheme</title>
                <para>
                  The Maven profiles for running the tests are configured to filter based on the
                  naming of the test class. The package layout is just a further convenience for the
                  developer for running the tests manually.

                <itemizedlist>
                  <listitem>Unit Tests test one class/method/feature in isolation from their dependencies by
                    using test doubles as replacement. They should be fast and need no special environment
                    setup for execution.
                  </listitem>
                  
                  <listitem>Filenames end with Test.java</listitem>
  
                  <listitem>Located in the normal package structure,
                    i.e. \outer.project.package\.\inner.project.package\
                  </listitem>
                  
                  <listitem>Integration Tests combine individual software modules to test their interaction with
                    each other. They do not need a special environment setup for execution.
                  </listitem>
  
                  <listitem>Filenames end with IT.java</listitem>
                  <listitem>Located in \outer.project.package\.it.\inner.project.package\</listitem>
  
                  <listitem>User Tests need a special execution environment and thus are not run
  	             automatically during any maven phase.
                  </listitem>
                  
                  <listitem>Filenames end with UT.java</listitem>
                  <listitem>Located in \outer.project.package\.ut.\inner.project.package\</listitem>
                </itemizedlist>
                </para>
            </section>
        </section>
        <section>
            <title>XML Formatting</title>
            <section>
                <title>File Format</title>
                <para>
                  Every XML file has to be UTF-8 encoded and has to use UNIX line endings.
                  Indentations consist of TWO spaces, tabstops are not allowed. The line length
                  shouldn't exceed 120 characters.
                </para>
            </section>
            <section>
                <title>Indent DTD properly</title>
                <para>
                  There should be a new line for every namespace:
<programlisting language="xml"><![CDATA[
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:build="urn:openengsb:build"
  xmlns:mvn="http://openengsb.org/connector/mvn/1.0"
  xmlns:xsi="http://http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="
    http://servicemix.apache.org/bean/1.0 http://servicemix.apache.org/schema/servicemix-bean-3.2.3.xsd
    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"
  />]]></programlisting>
                </para>
            </section>
            <section>
            <title>Eclipse Settings</title>
            <para>
              If you use Eclipse please choose these settings for your OpenEngSB workspace:
              <mediaobject>
               <imageobject>
                <imagedata id="form" fileref="graphics/eclipse-xml-settings.png"
                  format="png" width="400" align="center" />
                </imageobject>
                <caption>Eclipse XML Settigns</caption>
              </mediaobject>
            </para>
            </section>
            <section>
                <title>Recommended Readings</title>
                <para>
                  <itemizedlist>
                    <listitem>Clean Code, Robert C. Martin, 2008</listitem>
                    <listitem>Effective Java Second Edition, Joshua Bloch, 2008</listitem>
                    <listitem><ulink url="http://www.garshol.priv.no/blog/105.html">7 tips on writing clean code</ulink></listitem>
                  </itemizedlist>
                </para>
            </section>
        </section>

    </section>
</chapter>
