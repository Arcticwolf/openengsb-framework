<?xml version="1.0" encoding="UTF-8"?>
<!--

    Copyright 2010 OpenEngSB Division, Vienna University of Technology

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->

<chapter xml:id="developer.context" version="5.0" xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd
  http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd
  http://www.w3.org/2001/XMLSchema-instance http://www.w3.org/2001/XMLSchema-instance.xsd">

  <title>Context Management</title>

  <para>The OpenEngSB is capable of managing multiple contexts. Each context has its own metadata that may be read in
    UIs and workflows. This is important for the reuse of workflows in multiple projects (but offers also other
    possibilities).
    </para>

  <para>The
    <link xlink:href="${github}/core/common/src/main/java/org/openengsb/core/common/context/ContextHolder.java">
      ContextHolder
    </link>
    keeps track of the current threads' context. Invoking the set- and get-method will always
    manipulate the context of the current Thread. When a new Thread is spawned it inherits the context from the
    parent thread. This way connector-implementations always can handle actions according to the current context.
  </para>

  <para>The context is also used to handle the wiring of services in workflows. The workflow-engine declares global
    variables that are used in rules and processes. A variable is resolved by looking up the service with the same
    name in the current context. If no service with that name is available in the context it is looked up in the
    "root"-context.</para>

  <para>In detail the wiring is handled via the service-properties. Services contain properties where the key is of
    the format "location.&lt;contextid&gt;". The value is a list of "locations" where each location is delimited by
    square brackets ("[" and "]"). So a service may have several locations in several contexts.</para>

  <para>When a global variable is accessed during the execution of an action (from a process or rule), the
    osgi-context is queried for the correspinding service. The service wired to this variable must have location
    with the same name as the variable. The service is searched in the current context and the root-context. If no
    service is found, the action is stalled for 30 seconds. If there is still no service found an Exception is thrown.
    Internally this is handled using proxies. When the workflow service is started, all globals are populated with
    proxies, that automatically resolve the service with the corresponding location when a method is invoked.</para>

 <para>Example: The auditing-service is registered with the interface AuditingDomain. The service has property
   "location.root" with value "[auditing]". The workflow engine contains a global named "auditing" and a rule that
   invokes a method on every Event that is processed. When the rule fires and the consequence is executed, the proxy
   representing "auditing"-global queries for a service with the location.currentContext or the location.root
   containing "[auditing]". Since root-services get a service-ranking of "-1" by default, the service current context's
   would supersede the service located in the root-context.</para>

  <!-- TODO where is it stored? contextstore or domains? <para>Each project in the OpenEngSB has its own context to store meta information necessary for running inside of the
    OpenEngSB. The context basically is represented as a tree structure with key-value pairs as leafs.</para> -->

  <para>The context in which a workflow is executed, a rule fired or another action happens can be compared to the
  project in which the respective action happens. The context store therefore offers the possibility to perform
  project specific configurations.</para>

  <para>The <link xlink:href="${github}/core/common/src/main/java/org/openengsb/core/common/context/ContextService.java">context service</link>
  can be used to query the context and to insert, update or delete values. Note that under a specific name either a node or a leaf can be found, but not both. That means that
  the context can be compared to a file system, where context nodes are directories and context leaves files. The leaves in the context contain string key-value pairs.
  </para>

  <para>The <link xlink:href="${github}/core/common/src/main/java/org/openengsb/core/common/context/ContextCurrentService.java">current context service</link>
    extends the context service and provides additional methods for the management new root context entries (which correspond to projects).
  </para>





</chapter>

